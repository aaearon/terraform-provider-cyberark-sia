// Package provider implements the CyberArk SIA Terraform provider
package provider

import (
	"context"
	"fmt"

	"github.com/aaearon/terraform-provider-cyberark-sia/internal/client"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure the implementation satisfies expected interfaces
var (
	_ resource.Resource                = &CertificateResource{}
	_ resource.ResourceWithConfigure   = &CertificateResource{}
	_ resource.ResourceWithImportState = &CertificateResource{}
)

// NewCertificateResource is a helper function to simplify the provider implementation
func NewCertificateResource() resource.Resource {
	return &CertificateResource{}
}

// CertificateResource defines the resource implementation
type CertificateResource struct {
	providerData    *ProviderData
	certificatesAPI *client.CertificatesClient
}

// CertificateModel describes the resource data model
// Maps all 22 Terraform attributes from data-model.md
type CertificateModel struct {
	// Core Identifiers
	ID            types.String `tfsdk:"id"`             // Alias for certificate_id
	CertificateID types.String `tfsdk:"certificate_id"` // Unique certificate identifier

	// Input Attributes
	CertName        types.String `tfsdk:"cert_name"`        // Certificate name (optional, unique)
	CertBody        types.String `tfsdk:"cert_body"`        // PEM certificate content (must persist!)
	CertDescription types.String `tfsdk:"cert_description"` // Human-readable description
	CertType        types.String `tfsdk:"cert_type"`        // "PEM" (only format supported by SIA)
	DomainName      types.String `tfsdk:"domain_name"`      // Logical domain assignment
	Labels          types.Map    `tfsdk:"labels"`           // Key-value metadata

	// Computed Attributes
	ExpirationDate types.String `tfsdk:"expiration_date"` // Certificate expiration (ISO 8601)
	TenantID       types.String `tfsdk:"tenant_id"`       // Internal tenant identifier

	// Nested Metadata Block
	Metadata types.Object `tfsdk:"metadata"` // Certificate metadata (issuer, subject, etc.)
}

// CertificateMetadataModel represents the nested metadata block
type CertificateMetadataModel struct {
	Issuer                 types.String `tfsdk:"issuer"`                   // Certificate issuer DN
	Subject                types.String `tfsdk:"subject"`                  // Certificate subject DN
	ValidFrom              types.String `tfsdk:"valid_from"`               // Validity start (Unix timestamp)
	ValidTo                types.String `tfsdk:"valid_to"`                 // Validity end (Unix timestamp)
	SerialNumber           types.String `tfsdk:"serial_number"`            // Certificate serial number
	SubjectAlternativeName types.List   `tfsdk:"subject_alternative_name"` // SANs (string list)
}

// Metadata returns the resource type name
func (r *CertificateResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_certificate"
}

// Schema defines the resource schema
func (r *CertificateResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages a TLS/SSL certificate in CyberArk Secure Infrastructure Access. " +
			"Certificates are used by database workspaces for TLS-validated connections.",
		Attributes: map[string]schema.Attribute{
			// Core Identifiers
			"id": schema.StringAttribute{
				Description: "Unique certificate identifier (alias for certificate_id). " +
					"Automatically generated by SIA upon certificate creation.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"certificate_id": schema.StringAttribute{
				Description: "Unique certificate identifier. Automatically generated by SIA upon certificate creation.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},

			// Input Attributes
			"cert_name": schema.StringAttribute{
				Description: "Certificate name. Must be unique within the SIA tenant if provided. " +
					"If not provided, SIA may auto-generate a name.",
				Optional: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 255),
				},
			},
			"cert_body": schema.StringAttribute{
				Description: "PEM encoded certificate content. " +
					"Must be a valid X.509 certificate without private key material (public certificate only). " +
					"Maximum size: 4 KB. " +
					"CRITICAL: This attribute must persist in state as it's required for all update operations. " +
					"The API may normalize whitespace/line endings, so state will reflect server-side format.",
				Optional: true, // Cannot be Required+Computed (framework limitation)
				Computed: true, // API may normalize formatting (whitespace, line endings)
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(), // Persist for updates
					stringplanmodifier.RequiresReplace(),    // Change forces replacement
				},
				Validators: []validator.String{
					stringvalidator.LengthAtLeast(1), // Must not be empty
				},
			},
			"cert_description": schema.StringAttribute{
				Description: "Human-readable description of the certificate's purpose.",
				Optional:    true,
			},
			"cert_type": schema.StringAttribute{
				Description: "Certificate format. Only 'PEM' is supported by SIA. Defaults to 'PEM' if not specified.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("PEM"),
				},
			},
			"domain_name": schema.StringAttribute{
				Description: "Logical domain to which the certificate is assigned. " +
					"Used for organizational grouping of certificates.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				Description: "Key-value pairs for categorization and filtering. " +
					"Maximum 10 labels supported.",
				ElementType: types.StringType,
				Optional:    true,
				Validators: []validator.Map{
					mapvalidator.SizeAtMost(10),
				},
			},

			// Computed Attributes
			"expiration_date": schema.StringAttribute{
				Description: "Certificate expiration date in ISO 8601 format.",
				Computed:    true,
			},
			"tenant_id": schema.StringAttribute{
				Description: "Internal tenant identifier. Read-only.",
				Computed:    true,
			},

			// Nested Metadata Block
			"metadata": schema.SingleNestedAttribute{
				Description: "Certificate metadata extracted from the X.509 structure by SIA.",
				Computed:    true,
				Attributes: map[string]schema.Attribute{
					"issuer": schema.StringAttribute{
						Description: "Certificate issuer Distinguished Name (DN).",
						Computed:    true,
					},
					"subject": schema.StringAttribute{
						Description: "Certificate subject Distinguished Name (DN).",
						Computed:    true,
					},
					"valid_from": schema.StringAttribute{
						Description: "Certificate validity start time (Unix timestamp as string).",
						Computed:    true,
					},
					"valid_to": schema.StringAttribute{
						Description: "Certificate validity end time (Unix timestamp as string).",
						Computed:    true,
					},
					"serial_number": schema.StringAttribute{
						Description: "Certificate serial number in decimal format.",
						Computed:    true,
					},
					"subject_alternative_name": schema.ListAttribute{
						Description: "Subject Alternative Names (SANs). Empty array if none present.",
						ElementType: types.StringType,
						Computed:    true,
					},
				},
			},
		},
	}
}

// Configure adds the provider configured client to the resource
func (r *CertificateResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(*ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	// Initialize certificates client
	certsClient, err := client.NewCertificatesClient(ctx, providerData.AuthContext)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Initialize Certificates Client",
			fmt.Sprintf("Unable to create certificates client: %s", err.Error()),
		)
		return
	}

	r.certificatesAPI = certsClient
	r.providerData = providerData
}

// mapCertificateToState maps a certificate API response to a Terraform state model
// Centralizes the mapping logic used in Create, Read, and Update operations
func mapCertificateToState(ctx context.Context, cert *client.Certificate, model *CertificateModel, resp interface{}) {
	// resp can be *resource.CreateResponse, *resource.ReadResponse, or *resource.UpdateResponse
	// Extract the Diagnostics field using type assertion
	var diags *diag.Diagnostics
	switch r := resp.(type) {
	case *resource.CreateResponse:
		diags = &r.Diagnostics
	case *resource.ReadResponse:
		diags = &r.Diagnostics
	case *resource.UpdateResponse:
		diags = &r.Diagnostics
	default:
		// Should never happen
		return
	}

	// Map computed IDs and metadata
	model.ID = types.StringValue(cert.CertificateID)
	model.CertificateID = types.StringValue(cert.CertificateID)
	model.TenantID = types.StringValue(cert.TenantID)
	model.ExpirationDate = types.StringValue(cert.ExpirationDate)

	// Map input fields (returned by GET)
	if cert.CertName != "" {
		model.CertName = types.StringValue(cert.CertName)
	} else {
		model.CertName = types.StringNull()
	}
	if cert.CertDescription != "" {
		model.CertDescription = types.StringValue(cert.CertDescription)
	} else {
		model.CertDescription = types.StringNull()
	}
	if cert.DomainName != "" {
		model.DomainName = types.StringValue(cert.DomainName)
	} else {
		model.DomainName = types.StringNull()
	}

	// cert_body: Preserve plan value (Optional+Computed allows this)
	// The API may normalize whitespace differently than file(), causing perpetual diffs
	// Solution: Keep the user's original value from plan, don't overwrite with API response
	// This prevents "inconsistent result" errors from trailing newline differences
	// Note: cert_body is already in model from plan - we just don't overwrite it

	// Map labels if present
	if len(cert.Labels) > 0 {
		labelsMap, labelDiags := types.MapValueFrom(ctx, types.StringType, cert.Labels)
		diags.Append(labelDiags...)
		if !diags.HasError() {
			model.Labels = labelsMap
		}
	} else {
		model.Labels = types.MapNull(types.StringType)
	}

	// No additional computed fields to map beyond expiration_date and tenant_id (already mapped above)

	// Map metadata object if present
	if cert.Metadata != nil {
		// Convert SANs to types.List
		var sansList types.List
		if cert.Metadata.SubjectAlternativeName != nil {
			sansListVal, sansDiags := types.ListValueFrom(ctx, types.StringType, cert.Metadata.SubjectAlternativeName)
			diags.Append(sansDiags...)
			if !diags.HasError() {
				sansList = sansListVal
			}
		} else {
			sansList = types.ListNull(types.StringType)
		}

		// Build metadata object
		metadataModel := CertificateMetadataModel{
			Issuer:                 types.StringValue(cert.Metadata.Issuer),
			Subject:                types.StringValue(cert.Metadata.Subject),
			ValidFrom:              types.StringValue(cert.Metadata.ValidFrom),
			ValidTo:                types.StringValue(cert.Metadata.ValidTo),
			SerialNumber:           types.StringValue(cert.Metadata.SerialNumber),
			SubjectAlternativeName: sansList,
		}

		// Convert to types.Object
		metadataObj, metaDiags := types.ObjectValueFrom(ctx, map[string]attr.Type{
			"issuer":                   types.StringType,
			"subject":                  types.StringType,
			"valid_from":               types.StringType,
			"valid_to":                 types.StringType,
			"serial_number":            types.StringType,
			"subject_alternative_name": types.ListType{ElemType: types.StringType},
		}, metadataModel)
		diags.Append(metaDiags...)
		if !diags.HasError() {
			model.Metadata = metadataObj
		}
	}
}

// Create creates the certificate resource and sets the initial Terraform state
func (r *CertificateResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan CertificateModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Validate certificate content before API call (no expiration check per Issue #13)
	certBody := plan.CertBody.ValueString()
	if err := client.ValidatePEMCertificate(certBody); err != nil {
		resp.Diagnostics.AddError(
			"Invalid Certificate Content",
			fmt.Sprintf("Certificate validation failed: %s\n\n"+
				"Ensure cert_body contains a valid PEM-encoded certificate without private key material.", err.Error()),
		)
		return
	}

	// Prepare CREATE request
	createReq := &client.CertificateCreateRequest{
		CertBody: certBody,
	}

	// Add optional fields if provided
	if !plan.CertName.IsNull() && !plan.CertName.IsUnknown() {
		createReq.CertName = plan.CertName.ValueString()
	}
	if !plan.CertDescription.IsNull() && !plan.CertDescription.IsUnknown() {
		createReq.CertDescription = plan.CertDescription.ValueString()
	}
	if !plan.CertType.IsNull() && !plan.CertType.IsUnknown() {
		createReq.CertType = plan.CertType.ValueString()
	}
	if !plan.DomainName.IsNull() && !plan.DomainName.IsUnknown() {
		createReq.DomainName = plan.DomainName.ValueString()
	}
	if !plan.Labels.IsNull() && !plan.Labels.IsUnknown() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(plan.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Labels = labels
	}

	// Call API to create certificate
	tflog.Info(ctx, "Creating certificate", map[string]interface{}{
		"cert_name": createReq.CertName,
		// NEVER log cert_body or cert_password!
	})

	certificate, err := r.certificatesAPI.CreateCertificate(ctx, createReq)
	if err != nil {
		resp.Diagnostics.Append(client.MapCertificateError(err, "create certificate"))
		return
	}

	tflog.Info(ctx, "Certificate created successfully", map[string]interface{}{
		"certificate_id": certificate.CertificateID,
	})

	// Fetch full certificate details to populate ALL computed fields
	// CREATE response only returns 8 fields, but Terraform requires ALL computed fields to be known
	fullCertificate, err := r.certificatesAPI.GetCertificate(ctx, certificate.CertificateID)
	if err != nil {
		resp.Diagnostics.Append(client.MapCertificateError(err, "read certificate after create"))
		return
	}

	// DEBUG: Log the actual API response to see what we're getting
	tflog.Debug(ctx, "API GET Certificate Response", map[string]interface{}{
		"certificate_id": fullCertificate.CertificateID,
	})

	// Map GET response to Terraform state using helper
	// cert_body will be set from API response (handles server-side normalization)
	mapCertificateToState(ctx, fullCertificate, &plan, resp)
	if resp.Diagnostics.HasError() {
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// Read refreshes the Terraform state with the latest data from SIA
func (r *CertificateResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state CertificateModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get certificate ID from state
	certificateID := state.CertificateID.ValueString()

	tflog.Info(ctx, "Reading certificate", map[string]interface{}{
		"certificate_id": certificateID,
	})

	// Call API to get certificate details
	certificate, err := r.certificatesAPI.GetCertificate(ctx, certificateID)
	if err != nil {
		// Handle 404 Not Found: Remove from state (drift detection)
		if client.IsNotFoundError(err) {
			tflog.Warn(ctx, "Certificate not found, removing from state", map[string]interface{}{
				"certificate_id": certificateID,
			})
			resp.State.RemoveResource(ctx)
			return
		}

		// Other errors
		resp.Diagnostics.Append(client.MapCertificateError(err, "read certificate"))
		return
	}

	tflog.Info(ctx, "Certificate read successfully", map[string]interface{}{
		"certificate_id": certificate.CertificateID,
	})

	// Map GET response to Terraform state using helper
	mapCertificateToState(ctx, certificate, &state, resp)
	if resp.Diagnostics.HasError() {
		return
	}

	// Drift detection: Log state changes
	tflog.Debug(ctx, "Drift detection", map[string]interface{}{
		"certificate_id": certificate.CertificateID,
	})

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update updates the certificate resource and sets the updated Terraform state
func (r *CertificateResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state CertificateModel

	// Read Terraform plan and state data
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get certificate ID from state
	certificateID := state.CertificateID.ValueString()

	// CRITICAL: cert_body retrieval (Issue #4 - required for ALL updates)
	// cert_body may be unknown/null in plan if unchanged (UseStateForUnknown modifier)
	// Fallback to state value to ensure we always have cert_body for API
	certBody := plan.CertBody.ValueString()
	if certBody == "" || plan.CertBody.IsUnknown() {
		certBody = state.CertBody.ValueString()
	}

	// Validate certificate content if cert_body changed
	if certBody != state.CertBody.ValueString() {
		if err := client.ValidatePEMCertificate(certBody); err != nil {
			resp.Diagnostics.AddError(
				"Invalid Certificate Content",
				fmt.Sprintf("Certificate validation failed: %s\n\n"+
					"Ensure cert_body contains a valid PEM-encoded certificate without private key material.", err.Error()),
			)
			return
		}
	}

	// Prepare UPDATE request (cert_body is REQUIRED per Issue #4)
	updateReq := &client.CertificateUpdateRequest{
		CertBody: certBody, // REQUIRED for ALL updates!
	}

	// Add optional fields from plan (only include if not null/unknown)
	if !plan.CertName.IsNull() && !plan.CertName.IsUnknown() {
		updateReq.CertName = plan.CertName.ValueString()
	}
	if !plan.CertDescription.IsNull() && !plan.CertDescription.IsUnknown() {
		updateReq.CertDescription = plan.CertDescription.ValueString()
	}
	if !plan.CertType.IsNull() && !plan.CertType.IsUnknown() {
		updateReq.CertType = plan.CertType.ValueString()
	}

	if !plan.DomainName.IsNull() && !plan.DomainName.IsUnknown() {
		updateReq.DomainName = plan.DomainName.ValueString()
	}

	// Map labels if present
	if !plan.Labels.IsNull() && !plan.Labels.IsUnknown() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(plan.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		updateReq.Labels = labels
	}

	// Call API to update certificate
	tflog.Info(ctx, "Updating certificate", map[string]interface{}{
		"certificate_id": certificateID,
		"cert_name":      updateReq.CertName,
		// NEVER log cert_body or cert_password!
	})

	certificate, err := r.certificatesAPI.UpdateCertificate(ctx, certificateID, updateReq)
	if err != nil {
		resp.Diagnostics.Append(client.MapCertificateError(err, "update certificate"))
		return
	}

	tflog.Info(ctx, "Certificate updated successfully", map[string]interface{}{
		"certificate_id": certificate.CertificateID,
	})

	// Fetch full certificate details to populate ALL computed fields
	// UPDATE response only returns 8 fields, but Terraform requires ALL computed fields to be known
	fullCertificate, err := r.certificatesAPI.GetCertificate(ctx, certificate.CertificateID)
	if err != nil {
		resp.Diagnostics.Append(client.MapCertificateError(err, "read certificate after update"))
		return
	}

	tflog.Debug(ctx, "API GET Certificate Response after update", map[string]interface{}{
		"certificate_id": fullCertificate.CertificateID,
	})

	// Map GET response to Terraform state using helper
	// cert_body will be set from API response (handles server-side normalization)
	mapCertificateToState(ctx, fullCertificate, &plan, resp)
	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// Delete deletes the certificate resource
func (r *CertificateResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state CertificateModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get certificate ID from state
	certificateID := state.CertificateID.ValueString()

	tflog.Info(ctx, "Deleting certificate", map[string]interface{}{
		"certificate_id": certificateID,
	})

	// Call API to delete certificate
	err := r.certificatesAPI.DeleteCertificate(ctx, certificateID)
	if err != nil {
		// Map error to Terraform diagnostic (handles CERTIFICATE_IN_USE and other errors)
		resp.Diagnostics.Append(client.MapCertificateError(err, "delete certificate"))
		return
	}

	tflog.Info(ctx, "Certificate deleted successfully", map[string]interface{}{
		"certificate_id": certificateID,
	})

	// Note: State is automatically removed by Terraform framework after successful Delete()
	// No need to call resp.State.RemoveResource(ctx)
}

// ImportState imports an existing certificate into Terraform state
func (r *CertificateResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Use passthrough pattern: Import by certificate_id, then call Read() to populate state
	// Import syntax: terraform import cyberark_sia_certificate.example <certificate_id>
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)

	tflog.Info(ctx, "Importing certificate", map[string]interface{}{
		"certificate_id": req.ID,
	})
}
