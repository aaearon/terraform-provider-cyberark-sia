// Package provider implements the CyberArk SIA Terraform provider
package provider

import (
	"context"
	"fmt"

	"github.com/aaearon/terraform-provider-cyberark-sia/internal/client"
	"github.com/hashicorp/terraform-plugin-framework-validators/mapvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure the implementation satisfies expected interfaces
var (
	_ resource.Resource                = &CertificateResource{}
	_ resource.ResourceWithConfigure   = &CertificateResource{}
	_ resource.ResourceWithImportState = &CertificateResource{}
)

// NewCertificateResource is a helper function to simplify the provider implementation
func NewCertificateResource() resource.Resource {
	return &CertificateResource{}
}

// CertificateResource defines the resource implementation
type CertificateResource struct {
	providerData    *ProviderData
	certificatesAPI *client.CertificatesClient
}

// CertificateModel describes the resource data model
// Maps all 22 Terraform attributes from data-model.md
type CertificateModel struct {
	// Core Identifiers
	ID            types.String `tfsdk:"id"`             // Alias for certificate_id
	CertificateID types.String `tfsdk:"certificate_id"` // Unique certificate identifier

	// Input Attributes
	CertName        types.String `tfsdk:"cert_name"`        // Certificate name (optional, unique)
	CertBody        types.String `tfsdk:"cert_body"`        // PEM/DER certificate content (SENSITIVE, must persist!)
	CertDescription types.String `tfsdk:"cert_description"` // Human-readable description
	CertType        types.String `tfsdk:"cert_type"`        // "PEM" or "DER"
	CertPassword    types.String `tfsdk:"cert_password"`    // Password for encrypted certs (SENSITIVE, must persist!)
	DomainName      types.String `tfsdk:"domain_name"`      // Logical domain assignment
	Labels          types.Map    `tfsdk:"labels"`           // Key-value metadata

	// Computed Attributes
	ExpirationDate types.String `tfsdk:"expiration_date"` // Certificate expiration (ISO 8601)
	Checksum       types.String `tfsdk:"checksum"`        // SHA256 hash of cert_body
	Version        types.Int64  `tfsdk:"version"`         // Version number (increments on update)
	TenantID       types.String `tfsdk:"tenant_id"`       // Internal tenant identifier
	CreatedBy      types.String `tfsdk:"created_by"`      // User who created certificate
	LastUpdatedBy  types.String `tfsdk:"last_updated_by"` // User who last updated
	UpdatedTime    types.String `tfsdk:"updated_time"`    // Last modification timestamp

	// Nested Metadata Block
	Metadata types.Object `tfsdk:"metadata"` // Certificate metadata (issuer, subject, etc.)
}

// CertificateMetadataModel represents the nested metadata block
type CertificateMetadataModel struct {
	Issuer                 types.String `tfsdk:"issuer"`                   // Certificate issuer DN
	Subject                types.String `tfsdk:"subject"`                  // Certificate subject DN
	ValidFrom              types.String `tfsdk:"valid_from"`               // Validity start (Unix timestamp)
	ValidTo                types.String `tfsdk:"valid_to"`                 // Validity end (Unix timestamp)
	SerialNumber           types.String `tfsdk:"serial_number"`            // Certificate serial number
	SubjectAlternativeName types.List   `tfsdk:"subject_alternative_name"` // SANs (string list)
}

// Metadata returns the resource type name
func (r *CertificateResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_certificate"
}

// Schema defines the resource schema
func (r *CertificateResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages a TLS/SSL certificate in CyberArk Secure Infrastructure Access. " +
			"Certificates are used by database workspaces for TLS-validated connections.",
		Attributes: map[string]schema.Attribute{
			// Core Identifiers
			"id": schema.StringAttribute{
				Description: "Unique certificate identifier (alias for certificate_id). " +
					"Automatically generated by SIA upon certificate creation.",
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"certificate_id": schema.StringAttribute{
				Description: "Unique certificate identifier. Automatically generated by SIA upon certificate creation.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},

			// Input Attributes
			"cert_name": schema.StringAttribute{
				Description: "Certificate name. Must be unique within the SIA tenant if provided. " +
					"If not provided, SIA may auto-generate a name.",
				Optional: true,
				Validators: []validator.String{
					stringvalidator.LengthBetween(1, 255),
				},
			},
			"cert_body": schema.StringAttribute{
				Description: "PEM or DER encoded certificate content. " +
					"Must be a valid X.509 certificate without private key material. " +
					"CRITICAL: This attribute is sensitive and must persist in state for updates.",
				Required:  true,
				Sensitive: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(), // CRITICAL: Persist for updates!
				},
			},
			"cert_description": schema.StringAttribute{
				Description: "Human-readable description of the certificate's purpose.",
				Optional:    true,
			},
			"cert_type": schema.StringAttribute{
				Description: "Certificate format: 'PEM' or 'DER'. Defaults to 'PEM' if not specified.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
				Validators: []validator.String{
					stringvalidator.OneOf("PEM", "DER"),
				},
			},
			"cert_password": schema.StringAttribute{
				Description: "Password for encrypted/password-protected certificates. " +
					"Write-only field that must persist in state for updates.",
				Optional:  true,
				Sensitive: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(), // CRITICAL: Persist for updates!
				},
			},
			"domain_name": schema.StringAttribute{
				Description: "Logical domain to which the certificate is assigned. " +
					"Used for organizational grouping of certificates.",
				Optional: true,
			},
			"labels": schema.MapAttribute{
				Description: "Key-value pairs for categorization and filtering. " +
					"Maximum 10 labels supported.",
				ElementType: types.StringType,
				Optional:    true,
				Validators: []validator.Map{
					mapvalidator.SizeAtMost(10),
				},
			},

			// Computed Attributes
			"expiration_date": schema.StringAttribute{
				Description: "Certificate expiration date in ISO 8601 format.",
				Computed:    true,
			},
			"checksum": schema.StringAttribute{
				Description: "SHA256 hash of cert_body (64 hexadecimal characters). " +
					"Used for drift detection.",
				Computed: true,
			},
			"version": schema.Int64Attribute{
				Description: "Certificate version number. Starts at 1 and increments on each update. " +
					"Used for drift detection.",
				Computed: true,
			},
			"tenant_id": schema.StringAttribute{
				Description: "Internal tenant identifier. Read-only.",
				Computed:    true,
			},
			"created_by": schema.StringAttribute{
				Description: "Email address of the user who created the certificate.",
				Computed:    true,
			},
			"last_updated_by": schema.StringAttribute{
				Description: "Email address of the user who last updated the certificate. " +
					"Null if the certificate has never been updated. This field is managed by the API and cannot be set by users.",
				Optional: true,
				Computed: true,
			},
			"updated_time": schema.StringAttribute{
				Description: "Last modification timestamp in ISO 8601 format. " +
					"Used for drift detection.",
				Computed: true,
			},

			// Nested Metadata Block
			"metadata": schema.SingleNestedAttribute{
				Description: "Certificate metadata extracted from the X.509 structure by SIA.",
				Computed:    true,
				Attributes: map[string]schema.Attribute{
					"issuer": schema.StringAttribute{
						Description: "Certificate issuer Distinguished Name (DN).",
						Computed:    true,
					},
					"subject": schema.StringAttribute{
						Description: "Certificate subject Distinguished Name (DN).",
						Computed:    true,
					},
					"valid_from": schema.StringAttribute{
						Description: "Certificate validity start time (Unix timestamp as string).",
						Computed:    true,
					},
					"valid_to": schema.StringAttribute{
						Description: "Certificate validity end time (Unix timestamp as string).",
						Computed:    true,
					},
					"serial_number": schema.StringAttribute{
						Description: "Certificate serial number in decimal format.",
						Computed:    true,
					},
					"subject_alternative_name": schema.ListAttribute{
						Description: "Subject Alternative Names (SANs). Empty array if none present.",
						ElementType: types.StringType,
						Computed:    true,
					},
				},
			},
		},
	}
}

// Configure adds the provider configured client to the resource
func (r *CertificateResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	providerData, ok := req.ProviderData.(*ProviderData)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *ProviderData, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	// Initialize certificates client
	certsClient, err := client.NewCertificatesClient(providerData.ISPAuth)
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Initialize Certificates Client",
			fmt.Sprintf("Unable to create certificates client: %s", err.Error()),
		)
		return
	}

	r.certificatesAPI = certsClient
	r.providerData = providerData
}

// Create creates the certificate resource and sets the initial Terraform state
func (r *CertificateResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan CertificateModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Validate certificate content before API call (no expiration check per Issue #13)
	certBody := plan.CertBody.ValueString()
	if err := client.ValidatePEMCertificate(certBody); err != nil {
		resp.Diagnostics.AddError(
			"Invalid Certificate Content",
			fmt.Sprintf("Certificate validation failed: %s\n\n"+
				"Ensure cert_body contains a valid PEM-encoded certificate without private key material.", err.Error()),
		)
		return
	}

	// Prepare CREATE request
	createReq := &client.CertificateCreateRequest{
		CertBody: certBody,
	}

	// Add optional fields if provided
	if !plan.CertName.IsNull() && !plan.CertName.IsUnknown() {
		createReq.CertName = plan.CertName.ValueString()
	}
	if !plan.CertDescription.IsNull() && !plan.CertDescription.IsUnknown() {
		createReq.CertDescription = plan.CertDescription.ValueString()
	}
	if !plan.CertType.IsNull() && !plan.CertType.IsUnknown() {
		createReq.CertType = plan.CertType.ValueString()
	}
	if !plan.CertPassword.IsNull() && !plan.CertPassword.IsUnknown() {
		createReq.CertPassword = plan.CertPassword.ValueString()
	}
	if !plan.DomainName.IsNull() && !plan.DomainName.IsUnknown() {
		createReq.DomainName = plan.DomainName.ValueString()
	}
	if !plan.Labels.IsNull() && !plan.Labels.IsUnknown() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(plan.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		createReq.Labels = labels
	}

	// Call API to create certificate
	tflog.Info(ctx, "Creating certificate", map[string]interface{}{
		"cert_name": createReq.CertName,
		// NEVER log cert_body or cert_password!
	})

	certificate, err := r.certificatesAPI.CreateCertificate(ctx, createReq)
	if err != nil {
		resp.Diagnostics.Append(client.MapCertificateError(err, "create certificate"))
		return
	}

	tflog.Info(ctx, "Certificate created successfully", map[string]interface{}{
		"certificate_id": certificate.CertificateID,
	})

	// Fetch full certificate details to populate ALL computed fields
	// CREATE response only returns 8 fields, but Terraform requires ALL computed fields to be known
	fullCertificate, err := r.certificatesAPI.GetCertificate(ctx, certificate.CertificateID)
	if err != nil {
		resp.Diagnostics.Append(client.MapCertificateError(err, "read certificate after create"))
		return
	}

	// DEBUG: Log the actual API response to see what we're getting
	tflog.Debug(ctx, "API GET Certificate Response", map[string]interface{}{
		"certificate_id":   fullCertificate.CertificateID,
		"created_by":       fullCertificate.CreatedBy,
		"last_updated_by":  fullCertificate.LastUpdatedBy,
		"last_updated_nil": fullCertificate.LastUpdatedBy == nil,
	})

	// Map GET response (14 fields) to Terraform state
	plan.ID = types.StringValue(fullCertificate.CertificateID)
	plan.CertificateID = types.StringValue(fullCertificate.CertificateID)
	plan.TenantID = types.StringValue(fullCertificate.TenantID)
	plan.ExpirationDate = types.StringValue(fullCertificate.ExpirationDate)

	// Map input fields (returned by GET)
	if fullCertificate.CertName != "" {
		plan.CertName = types.StringValue(fullCertificate.CertName)
	}
	if fullCertificate.CertDescription != "" {
		plan.CertDescription = types.StringValue(fullCertificate.CertDescription)
	}
	if fullCertificate.DomainName != "" {
		plan.DomainName = types.StringValue(fullCertificate.DomainName)
	}

	// Map labels if present
	if fullCertificate.Labels != nil && len(fullCertificate.Labels) > 0 {
		labelsMap, diags := types.MapValueFrom(ctx, types.StringType, fullCertificate.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			plan.Labels = labelsMap
		}
	}

	// Map computed fields (returned by GET, not CREATE)
	if fullCertificate.Checksum != "" {
		plan.Checksum = types.StringValue(fullCertificate.Checksum)
	}
	plan.Version = types.Int64Value(int64(fullCertificate.Version))
	if fullCertificate.CreatedBy != "" {
		plan.CreatedBy = types.StringValue(fullCertificate.CreatedBy)
	}
	// LastUpdatedBy is a pointer - properly handle JSON null vs absent vs empty
	if fullCertificate.LastUpdatedBy != nil && *fullCertificate.LastUpdatedBy != "" {
		plan.LastUpdatedBy = types.StringValue(*fullCertificate.LastUpdatedBy)
	} else {
		plan.LastUpdatedBy = types.StringNull()
	}
	if fullCertificate.UpdatedTime != "" {
		plan.UpdatedTime = types.StringValue(fullCertificate.UpdatedTime)
	}

	// Map metadata object if present
	if fullCertificate.Metadata != nil {
		// Convert SANs to types.List
		sansList, diags := types.ListValueFrom(ctx, types.StringType, fullCertificate.Metadata.SubjectAlternativeName)
		resp.Diagnostics.Append(diags...)
		if resp.Diagnostics.HasError() {
			return
		}

		// Build metadata object
		metadataModel := CertificateMetadataModel{
			Issuer:                 types.StringValue(fullCertificate.Metadata.Issuer),
			Subject:                types.StringValue(fullCertificate.Metadata.Subject),
			ValidFrom:              types.StringValue(fullCertificate.Metadata.ValidFrom),
			ValidTo:                types.StringValue(fullCertificate.Metadata.ValidTo),
			SerialNumber:           types.StringValue(fullCertificate.Metadata.SerialNumber),
			SubjectAlternativeName: sansList,
		}

		// Convert to types.Object
		metadataObj, diags := types.ObjectValueFrom(ctx, map[string]attr.Type{
			"issuer":                   types.StringType,
			"subject":                  types.StringType,
			"valid_from":               types.StringType,
			"valid_to":                 types.StringType,
			"serial_number":            types.StringType,
			"subject_alternative_name": types.ListType{ElemType: types.StringType},
		}, metadataModel)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			plan.Metadata = metadataObj
		}
	}

	// CertBody must persist in state (already in plan, UseStateForUnknown ensures it stays)
	// CertPassword must persist in state (already in plan, UseStateForUnknown ensures it stays)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// Read refreshes the Terraform state with the latest data from SIA
func (r *CertificateResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state CertificateModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get certificate ID from state
	certificateID := state.CertificateID.ValueString()

	tflog.Info(ctx, "Reading certificate", map[string]interface{}{
		"certificate_id": certificateID,
	})

	// Call API to get certificate details
	certificate, err := r.certificatesAPI.GetCertificate(ctx, certificateID)
	if err != nil {
		// Handle 404 Not Found: Remove from state (drift detection)
		if client.IsNotFoundError(err) {
			tflog.Warn(ctx, "Certificate not found, removing from state", map[string]interface{}{
				"certificate_id": certificateID,
			})
			resp.State.RemoveResource(ctx)
			return
		}

		// Other errors
		resp.Diagnostics.Append(client.MapCertificateError(err, "read certificate"))
		return
	}

	tflog.Info(ctx, "Certificate read successfully", map[string]interface{}{
		"certificate_id": certificate.CertificateID,
		"version":        certificate.Version,
	})

	// Map GET response (14 fields) to Terraform state
	state.ID = types.StringValue(certificate.CertificateID)
	state.CertificateID = types.StringValue(certificate.CertificateID)
	state.TenantID = types.StringValue(certificate.TenantID)

	// Map input fields (returned by GET)
	if certificate.CertName != "" {
		state.CertName = types.StringValue(certificate.CertName)
	} else {
		state.CertName = types.StringNull()
	}
	if certificate.CertDescription != "" {
		state.CertDescription = types.StringValue(certificate.CertDescription)
	} else {
		state.CertDescription = types.StringNull()
	}
	if certificate.DomainName != "" {
		state.DomainName = types.StringValue(certificate.DomainName)
	} else {
		state.DomainName = types.StringNull()
	}

	// cert_body IS returned by GET (Issue #4 confirmed) - store in state
	if certificate.CertBody != "" {
		state.CertBody = types.StringValue(certificate.CertBody)
	}

	// cert_password is write-only, keep existing state value
	// (UseStateForUnknown plan modifier ensures it persists)

	// Map labels
	if certificate.Labels != nil && len(certificate.Labels) > 0 {
		labelsMap, diags := types.MapValueFrom(ctx, types.StringType, certificate.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			state.Labels = labelsMap
		}
	} else {
		state.Labels = types.MapNull(types.StringType)
	}

	// Map computed attributes
	state.ExpirationDate = types.StringValue(certificate.ExpirationDate)
	state.Checksum = types.StringValue(certificate.Checksum)
	state.Version = types.Int64Value(int64(certificate.Version))
	state.CreatedBy = types.StringValue(certificate.CreatedBy)

	// LastUpdatedBy is a pointer - properly handle JSON null vs absent vs empty
	if certificate.LastUpdatedBy != nil && *certificate.LastUpdatedBy != "" {
		state.LastUpdatedBy = types.StringValue(*certificate.LastUpdatedBy)
	} else {
		state.LastUpdatedBy = types.StringNull()
	}

	state.UpdatedTime = types.StringValue(certificate.UpdatedTime)

	// Map nested metadata block
	if certificate.Metadata != nil {
		metadataModel := CertificateMetadataModel{
			Issuer:       types.StringValue(certificate.Metadata.Issuer),
			Subject:      types.StringValue(certificate.Metadata.Subject),
			ValidFrom:    types.StringValue(certificate.Metadata.ValidFrom),
			ValidTo:      types.StringValue(certificate.Metadata.ValidTo),
			SerialNumber: types.StringValue(certificate.Metadata.SerialNumber),
		}

		// Map SANs (array)
		if certificate.Metadata.SubjectAlternativeName != nil {
			sansList, diags := types.ListValueFrom(ctx, types.StringType, certificate.Metadata.SubjectAlternativeName)
			resp.Diagnostics.Append(diags...)
			if !resp.Diagnostics.HasError() {
				metadataModel.SubjectAlternativeName = sansList
			}
		} else {
			// Empty array
			metadataModel.SubjectAlternativeName = types.ListNull(types.StringType)
		}

		// Convert metadata model to types.Object
		metadataAttrTypes := map[string]attr.Type{
			"issuer":                   types.StringType,
			"subject":                  types.StringType,
			"valid_from":               types.StringType,
			"valid_to":                 types.StringType,
			"serial_number":            types.StringType,
			"subject_alternative_name": types.ListType{ElemType: types.StringType},
		}
		metadataValues := map[string]attr.Value{
			"issuer":                   metadataModel.Issuer,
			"subject":                  metadataModel.Subject,
			"valid_from":               metadataModel.ValidFrom,
			"valid_to":                 metadataModel.ValidTo,
			"serial_number":            metadataModel.SerialNumber,
			"subject_alternative_name": metadataModel.SubjectAlternativeName,
		}
		metadataObj, diags := types.ObjectValue(metadataAttrTypes, metadataValues)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			state.Metadata = metadataObj
		}
	}

	// Drift detection: Log if version/checksum/updated_time changed
	tflog.Debug(ctx, "Drift detection", map[string]interface{}{
		"certificate_id": certificate.CertificateID,
		"version":        certificate.Version,
		"checksum":       certificate.Checksum,
		"updated_time":   certificate.UpdatedTime,
	})

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update updates the certificate resource and sets the updated Terraform state
func (r *CertificateResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state CertificateModel

	// Read Terraform plan and state data
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get certificate ID from state
	certificateID := state.CertificateID.ValueString()

	// CRITICAL: cert_body retrieval (Issue #4 - required for ALL updates)
	// cert_body may be unknown/null in plan if unchanged (UseStateForUnknown modifier)
	// Fallback to state value to ensure we always have cert_body for API
	certBody := plan.CertBody.ValueString()
	if certBody == "" || plan.CertBody.IsUnknown() {
		certBody = state.CertBody.ValueString()
	}

	// Validate certificate content if cert_body changed
	if certBody != state.CertBody.ValueString() {
		if err := client.ValidatePEMCertificate(certBody); err != nil {
			resp.Diagnostics.AddError(
				"Invalid Certificate Content",
				fmt.Sprintf("Certificate validation failed: %s\n\n"+
					"Ensure cert_body contains a valid PEM-encoded certificate without private key material.", err.Error()),
			)
			return
		}
	}

	// Prepare UPDATE request (cert_body is REQUIRED per Issue #4)
	updateReq := &client.CertificateUpdateRequest{
		CertBody: certBody, // REQUIRED for ALL updates!
	}

	// Add optional fields from plan (only include if not null/unknown)
	if !plan.CertName.IsNull() && !plan.CertName.IsUnknown() {
		updateReq.CertName = plan.CertName.ValueString()
	}
	if !plan.CertDescription.IsNull() && !plan.CertDescription.IsUnknown() {
		updateReq.CertDescription = plan.CertDescription.ValueString()
	}
	if !plan.CertType.IsNull() && !plan.CertType.IsUnknown() {
		updateReq.CertType = plan.CertType.ValueString()
	}

	// cert_password: Same fallback pattern as cert_body
	certPassword := plan.CertPassword.ValueString()
	if certPassword == "" && plan.CertPassword.IsUnknown() && !state.CertPassword.IsNull() {
		certPassword = state.CertPassword.ValueString()
	}
	if certPassword != "" {
		updateReq.CertPassword = certPassword
	}

	if !plan.DomainName.IsNull() && !plan.DomainName.IsUnknown() {
		updateReq.DomainName = plan.DomainName.ValueString()
	}

	// Map labels if present
	if !plan.Labels.IsNull() && !plan.Labels.IsUnknown() {
		labels := make(map[string]string)
		resp.Diagnostics.Append(plan.Labels.ElementsAs(ctx, &labels, false)...)
		if resp.Diagnostics.HasError() {
			return
		}
		updateReq.Labels = labels
	}

	// Call API to update certificate
	tflog.Info(ctx, "Updating certificate", map[string]interface{}{
		"certificate_id": certificateID,
		"cert_name":      updateReq.CertName,
		// NEVER log cert_body or cert_password!
	})

	certificate, err := r.certificatesAPI.UpdateCertificate(ctx, certificateID, updateReq)
	if err != nil {
		resp.Diagnostics.Append(client.MapCertificateError(err, "update certificate"))
		return
	}

	tflog.Info(ctx, "Certificate updated successfully", map[string]interface{}{
		"certificate_id": certificate.CertificateID,
		"version":        certificate.Version,
	})

	// Map UPDATE response to Terraform state (8 fields from UPDATE response)
	plan.ID = types.StringValue(certificate.CertificateID)
	plan.CertificateID = types.StringValue(certificate.CertificateID)
	plan.TenantID = types.StringValue(certificate.TenantID)
	plan.ExpirationDate = types.StringValue(certificate.ExpirationDate)

	// CertBody must persist in state (UseStateForUnknown ensures it stays)
	plan.CertBody = types.StringValue(certBody)

	// CertPassword must persist in state (UseStateForUnknown ensures it stays)
	if certPassword != "" {
		plan.CertPassword = types.StringValue(certPassword)
	}

	// Map optional fields from response if present
	if certificate.CertName != "" {
		plan.CertName = types.StringValue(certificate.CertName)
	} else {
		plan.CertName = types.StringNull()
	}
	if certificate.CertDescription != "" {
		plan.CertDescription = types.StringValue(certificate.CertDescription)
	} else {
		plan.CertDescription = types.StringNull()
	}
	if certificate.DomainName != "" {
		plan.DomainName = types.StringValue(certificate.DomainName)
	} else {
		plan.DomainName = types.StringNull()
	}

	// Map labels if present
	if certificate.Labels != nil && len(certificate.Labels) > 0 {
		labelsMap, diags := types.MapValueFrom(ctx, types.StringType, certificate.Labels)
		resp.Diagnostics.Append(diags...)
		if !resp.Diagnostics.HasError() {
			plan.Labels = labelsMap
		}
	} else {
		plan.Labels = types.MapNull(types.StringType)
	}

	// Note: UPDATE response does NOT include metadata, checksum, version, audit fields
	// These will be populated on next Read/Refresh

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}

// Delete deletes the certificate resource
func (r *CertificateResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state CertificateModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Get certificate ID from state
	certificateID := state.CertificateID.ValueString()

	tflog.Info(ctx, "Deleting certificate", map[string]interface{}{
		"certificate_id": certificateID,
	})

	// Call API to delete certificate
	err := r.certificatesAPI.DeleteCertificate(ctx, certificateID)
	if err != nil {
		// Map error to Terraform diagnostic (handles CERTIFICATE_IN_USE and other errors)
		resp.Diagnostics.Append(client.MapCertificateError(err, "delete certificate"))
		return
	}

	tflog.Info(ctx, "Certificate deleted successfully", map[string]interface{}{
		"certificate_id": certificateID,
	})

	// Note: State is automatically removed by Terraform framework after successful Delete()
	// No need to call resp.State.RemoveResource(ctx)
}

// ImportState imports an existing certificate into Terraform state
func (r *CertificateResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	// Use passthrough pattern: Import by certificate_id, then call Read() to populate state
	// Import syntax: terraform import cyberark_sia_certificate.example <certificate_id>
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)

	tflog.Info(ctx, "Importing certificate", map[string]interface{}{
		"certificate_id": req.ID,
	})
}
